---
title: "Data Visualization with ggplot2"
teaching: 45
exercises: 30
questions:
- "How can I create simple plots with ggplot?"
- "What is faceting in ggplot?"
- "How can I change the aestetics (e.g. axis labels and color) of a plot?"
objectives:
- "Produce scatter plots, boxplots, and barplots using ggplot."
- "Set universal plot settings."
- "Describe what faceting is and apply faceting in ggplot."
- "Modify the aesthetics of an existing ggplot plot (including axis labels and color)."
- "Build complex and customized plots from data in a data frame."

keypoints:
- "ggplot2 is powerful data visualization package in R."
- "ggplot2 lets the user add, remove or change components of a plot."
- "Plots created with ggplot2 can be customized in many ways, which make
  the package very useful."

source: Rmd
---

```{r, include=FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("05-")
```
We start by loading the required packages. **`ggplot2`** is included in
the **`tidyverse`** package.

```{r load-package, message=FALSE, purl=FALSE}
library(tidyverse)
```

If not still in the workspace, load the two small datasets that we created in
the previous episode.

```{r load-data, eval = FALSE, purl = FALSE}
cnts_sml_long <- read_csv("gene_counts_sml_long.csv")
cnts_sml_wide <- read_csv("gene_counts_sml_wide.csv")
```

```{r, echo = FALSE, eval = TRUE, include = FALSE, purl = FALSE}
## silently read in CSV files
cnts_sml_long <- read_csv("../data/gene_counts_sml_long.csv")
cnts_sml_wide <- read_csv("../data/gene_counts_sml_wide.csv")
```

To make the `cnts_sml_wide` dataset a bit more interesting for the plotting in
this episode, we will add a fictional column as a factor that we call
`gene_category`:

```{r purl = FALSE}
cnts_sml_wide$gene_category = factor(c(
    2, 2, 1, 1, 1, 3, 3, 1, 1, 1, 3, 3, 1, 3, 3, 2, 2, 3, 3, 2, 2, 2, 2, 3, 2,
    1, 2, 3, 2, 3, 1, 3, 1, 2, 3, 2, 1, 2, 3, 1, 1, 1, 3, 2, 1, 2, 2, 3, 3, 1))

head(cnts_sml_wide)
```

## Plotting with **`ggplot2`**

**`ggplot2`** is a plotting package that makes it simple to create complex plots
from data in a data frame. It provides a more programmatic interface for
specifying what variables to plot, how they are displayed, and general visual
properties. Therefore, we only need minimal changes if the underlying data 
change or if we decide to change from a bar plot to a scatterplot. This helps in 
creating publication quality plots with minimal amounts of adjustments and 
tweaking.

**`ggplot2`** plots work best with data in the 'long' format, i.e. a column for
every dimension, and a row for every observation. Well-structured data will save
you lots of time when making figures with **`ggplot2`**.

ggplot graphics are built layer by layer by adding new elements. Adding layers
in this fashion allows for extensive flexibility and customization of plots.

To build a ggplot, we will use the following basic template that can be used for
different types of plots:

```
ggplot(data = <DATA>, mapping = aes(<MAPPINGS>)) +  <GEOM_FUNCTION>()
```

- use the `ggplot()` function and bind the plot to a specific data frame using 
  the `data` argument:

```{r, eval = FALSE, purl = FALSE}
ggplot(data = cnts_sml_wide)
```

- define an aesthetic mapping (using the aesthetic (`aes`) function), by 
  selecting the variables to be plotted and specifying how to present them in
  the graph, e.g. as x/y positions, or characteristics such as size, shape,
  color, etc:      

```{r, eval = FALSE, purl = FALSE}
ggplot(data = cnts_sml_wide, mapping = aes(x = A_Wt, y = D_Hom))
```

- add 'geoms' (geometric objects) â€“ graphical representations of the data in the
  plot (points, lines, bars). **`ggplot2`** offers many different geoms; we will
  use some common ones today, including:
  
  * `geom_point()` for scatter plots, dot plots, etc.
  * `geom_boxplot()` for, well, boxplots!
  * `geom_bar()` for displaying relations between numeric and categorical variables. 

To add a geom to the plot use `+` operator. Let's first try `geom_point()`:

```{r first-ggplot, purl = FALSE}
ggplot(data = cnts_sml_wide, mapping = aes(x = A_Wt, y = D_Hom)) +
  geom_point()
```

The `+` in the **`ggplot2`** package is particularly useful because it allows 
you to modify existing `ggplot` objects. This means you can easily set up plot
"templates" and conveniently explore different types of plots, so the above
plot can also be generated with code like this:

```{r, first-ggplot-with-plus, eval = FALSE, purl = FALSE}
# Assign plot to a variable
cnts_plot <- ggplot(data = cnts_sml_wide, 
                           mapping = aes(x = A_Wt, y = D_Hom))

# Draw the plot
cnts_plot + 
  geom_point()
```

```{r, eval = FALSE, purl = TRUE, echo = FALSE, purl = FALSE}
## Create a ggplot and draw it.
cnts_plot <- ggplot(data = cnts_sml_wide, 
                           mapping = aes(x = A_Wt, y = D_Hom))

cnts_plot + 
  geom_point()
```

**Notes**

- Anything you put in the `ggplot()` function can be seen by any geom layers
  that you add (i.e. these are universal plot settings). This includes the x- 
  and y-axis you set up in `aes()`.
- You can also specify aesthetics for a given geom independently of the
  aesthetics defined globally in the `ggplot()` function.
- The `+` sign used to add layers must be placed at the end of each line 
  containing a layer. If, instead, the `+` sign is added in the line before the 
  other layer, **`ggplot2`** will not add the new layer and will return an error 
  message.

```{r, ggplot-with-plus-position, eval=FALSE, purl=FALSE}
# This is the correct syntax for adding layers
cnts_plot +
  geom_point()

# This will not add the new layer and will return an error message
cnts_plot
  + geom_point()
```

> ## Challenge 5.1 (optional)
>
> Scatter plots can be useful exploratory tools for small datasets. For data
> sets with large numbers of observations, overplotting of points can be a
> limitation of scatter plots. One strategy for handling such settings is to use
> hexagonal binning of observations. The plot space is tessellated into
> hexagons. Each hexagon is assigned a color based on the number of observations
> that fall within its boundaries. To use hexagonal binning with **`ggplot2`**, 
> first install the R package `hexbin` from CRAN:
>
>
> ```{r, eval = FALSE}
  install.packages("hexbin")
  library(hexbin)
```
>
> Then use the `geom_hex()` function:
>
> ```{r, eval = FALSE}
  cnts_plot +
  geom_hex()
```
>
> - What are the relative strengths and weaknesses of a hexagonal bin plot
>   compared to a scatter plot? Examine the above scatter plot and compare it
>   with the hexagonal bin plot that you created.
{: .challenge}


## Building your plots iteratively

Building plots with **`ggplot2`** is typically an iterative process. We start by
defining the dataset we'll use, lay out the axes, and choose a geom:

```{r create-ggplot-object, purl = FALSE}
ggplot(data = cnts_sml_wide, mapping = aes(x = A_Wt, y = D_Hom)) +
    geom_point()
```

Then, we start modifying this plot to extract more information from it. For
instance, we can add transparency (`alpha`) to avoid overplotting:

```{r adding-transparency, purl = FALSE}
ggplot(data = cnts_sml_wide, mapping = aes(x = A_Wt, y = D_Hom)) +
    geom_point(alpha = 0.5)
```

We can also add colors for all the points:

```{r adding-colors, purl=FALSE}
ggplot(data = cnts_sml_wide, mapping = aes(x = A_Wt, y = D_Hom)) +
    geom_point(alpha = 0.5, color = "blue")
```

Or to color each point in the plot differently, you could use a vector as an
input to the argument **color**. **`ggplot2`** will provide a different color
corresponding to different values in the vector. Here is an example where we
color with **`gene`**:


```{r color-by-gene-category-1, purl=FALSE}
ggplot(data = cnts_sml_wide, mapping = aes(x = A_Wt, y = D_Hom)) +
    geom_point(alpha = 0.5, aes(color = gene_category))
```

> ## Challenge 5.2
>
> Use what you just learned to create a scatter plot of the gene category against
> the counts for sample `A_Wt`. Is this a good way to show this type of data?
>
>> ## Solution
>>
>> ```{r scatter-challenge-answer, answer=TRUE, purl=FALSE}
ggplot(data = cnts_sml_wide, 
       mapping = aes(x = gene_category, y = A_Wt)) +
  geom_point(aes(color = gene_category))
```
>> Since we have counts that varies over a wide range, one could for example
>> use a logarithmic y-scale instead:
>>
>> ```{r scatter-challenge-answer2, answer=TRUE, purl=FALSE}
ggplot(data = cnts_sml_wide, 
       mapping = aes(x = gene_category, y = A_Wt)) +
  geom_point(aes(color = gene_category)) +
  scale_y_log10()
```
> {: .solution}
{: .challenge}


## Boxplot

Another useful way to visualize and compare distributions across groups is the
boxplot. Here we will use the `cnts_sml_long` data frame that have all the
counts in a single column. We will first create a boxplot that visualizes the
distribution of counts within each sample:

```{r boxplot, purl=FALSE}
ggplot(data = cnts_sml_long, mapping = aes(x = sample, y = cnt)) +
    geom_boxplot()
```

By adding points to the boxplot, we can have a better idea of the number of
counts and of their distribution:

```{r boxplot-with-points, purl=FALSE}
ggplot(data = cnts_sml_long, mapping = aes(x = sample, y = cnt)) +
    geom_boxplot(alpha = 0) +
    geom_jitter(alpha = 0.5, color = "tomato")
```

Notice how the boxplot layer is behind the jitter layer? What do you need to
change in the code to put the boxplot in front of the points such that it's not
hidden?

> ## Challenges 5.3
>
> Use the code below, and try to incrementally make changes to the plot.
>
>```{r box-with-points-challenge, eval=FALSE, echo=TRUE, purl=FALSE}
ggplot(data = cnts_sml_long, mapping = aes(x = sample, y = cnt)) +
    geom_boxplot(alpha = 0) +
    geom_jitter(alpha = 0.5, color = "tomato")
```
>
> Boxplots are useful summaries, but hide the *shape* of the distribution. For
> example, if there is a bimodal distribution, it would not be observed with a
> boxplot. An alternative to the boxplot is the violin plot (sometimes known as 
> a beanplot), where the shape (of the density of points) is drawn.
>
> * Replace the box plot with a violin plot; see `geom_violin()`.
>
>> ## Solution
>>
>> ```{r violinplot-with-points, eval=FALSE, echo=TRUE, purl=FALSE}
# Violin plot instead of boxplot
ggplot(data = cnts_sml_long, mapping = aes(x = sample, y = cnt)) +
    geom_boxplot(alpha = 0) +
    geom_jitter(alpha = 0.5, color = "tomato")
```
> {: .solution}
>
> In many types of data, it is important to consider the *scale* of the
> observations. For example, it may be worth changing the scale of the axis to
> better distribute the observations in the space of the plot. Changing the
> scale of the axes is done similarly to adding/modifying other components:
>
> * Represent the read counts on the log~10~ scale; see `scale_y_log10()`.
>
>> ## Solution
>>
>>```{r violinplot-logscale-answer, purl=FALSE}
# Violin plot with log-scale
ggplot(data = cnts_sml_long, mapping = aes(x = sample, y = cnt)) +
  geom_violin(alpha = 0) +
  geom_jitter(alpha = 0.5, color = "tomato") +
  scale_y_log10()
```
> {: .solution}
>
> * We've now looked at the distribution of the counts within samples. Try
>   making a new plot to explore the distribution for each `genotype` instead.
>   Overlay the boxplot layer on a jitter layer to show actual counts.
>
>> ## Solution
>>
>> ```{r violinplot-by-genotype-answer, purl=FALSE}
# Violin plot by genotype
ggplot(data = cnts_sml_long, mapping = aes(x = genotype, y = cnt)) +
  geom_violin(alpha = 0) +
  geom_jitter(alpha = 0.5, color = "tomato") +
  scale_y_log10()
```
> {: .solution}
>
> * Add color to the data points on your boxplot according to the sample's
>   genotype of the actual sample.
>
>> ## Solution
>>
>> ```{r violinplot-by-genotype-color-answer, purl=FALSE}
# Violin plot by genotype in color
ggplot(data = cnts_sml_long, mapping = aes(x = genotype, y = cnt)) +
  geom_violin(alpha = 0) +
  geom_jitter(alpha = 0.5, aes(color = genotype)) +
  scale_y_log10()
```
> {: .solution}
>
> * Reorder the genotype categories so that "Wt" is shown to the left and "Hom"
>   to the right (**hint:** use the `factor()` function).
>
>> ## Solution
>>
>> ```{r violinplot-by-genotype-ordering-answer, purl=FALSE}
# Violin plot by reordered genotypes

# Create a factor with reordered levels
cnts_sml_long$genotype <- factor(cnts_sml_long$genotype, levels = c("Wt", "Hom"))

# Now create the plot in the same way as before
ggplot(data = cnts_sml_long, mapping = aes(x = genotype, y = cnt)) +
  geom_violin(alpha = 0) +
  geom_jitter(alpha = 0.5, aes(color = genotype)) +
  scale_y_log10()
```
> {: .solution}
{: .challenge}

## Barplot

Another common type of plot is the barplot. This kind of plot can be created 
with `geom_bar()`. In order to create a barplot, we will first prepare a
suitable dataset:

```{r barplot-data, purl = FALSE}
# Filter out the rows for the gene 'Mpc2'
cnts_Mpc2 <- cnts_sml_long %>% filter(gene == "Mpc2")

cnts_Mpc2
```

Let's then create a barplot from the tiny dataset that we just created:

```{r barplot1, purl = FALSE}
ggplot(cnts_Mpc2, aes(x = sample, y = cnt)) +
  geom_bar(stat = "identity")
```

In the code above, we used the argument `stat = "identity"` instead of the
default value `bin`. This means that the height of the bar will be represented by
the count in each category.

We can improve the plot by using different fill colors for the genotypes:

```{r barplot2, purl = FALSE}
ggplot(cnts_Mpc2, aes(x = sample, y = cnt, fill = genotype)) +
  geom_bar(stat = "identity")
```

We could also have added this configuration to the `geom_bar()` layer instead:

```{r barplot3, eval = FALSE, purl = FALSE}
ggplot(cnts_Mpc2, aes(x = sample, y = cnt)) +
  geom_bar(stat = "identity", aes(fill = genotype))
```

## Integrating the pipe operator with ggplot2

In the previous lesson, we saw how to use the pipe operator `%>%` to use
different functions in a sequence and create a coherent workflow.
We can also use the pipe operator to pass the `data` argument to the
`ggplot()` function. The hard part is to remember that to build your ggplot,
you need to use `+` and not `%>%`.

```{r integrating-the-pipe, purl=FALSE}
cnts_Mpc2 %>% ggplot(aes(x = sample, y = cnt, fill = genotype)) +
  geom_bar(stat = "identity")
```

The pipe operator can also be used to link data manipulation with consequent
data visualization.

```{r pipes-and-manipulation, purl=FALSE}
cnts_Mpc2_graph <- cnts_sml_long %>%
  filter(gene == "Mpc2") %>% 
  ggplot(aes(x = sample, y = cnt, fill = genotype)) +
  geom_bar(stat = "identity")

cnts_Mpc2_graph
```

## Faceting

`ggplot` has a special technique called *faceting* that allows the user to split 
one plot into multiple plots based on a factor included in the dataset. We will 
use it to make one barplot for each of three genes:

```{r first-facet, purl = FALSE}
cnts_sml_long %>%
  # Filter out three genes
  filter(gene %in% c("Evc", "Mpc2", "Nemf")) %>%
  # Create a separate barplot for each gene
  ggplot(aes(x = sample, y = cnt, fill = genotype)) +
    geom_bar(stat = "identity") +
    facet_wrap(facets = vars(gene))
```

You can also create more advanced layouts using the `facet_grid()` function.
We can for example arrange the plots vertically instead of horizontally:


```{r facet-in-rows, purl = FALSE}
cnts_sml_long %>%
    # Filter out three genes
    filter(gene %in% c("Evc", "Mpc2", "Nemf")) %>%
    # Create a separate barplot for each gene
    ggplot(aes(x = sample, y = cnt, fill = genotype)) +
    geom_bar(stat = "identity") +
    facet_grid(rows = vars(gene))
```

**Note:** 
`ggplot2` before version 3.0.0 used formulas to specify how plots are faceted.
If you encounter `facet_grid`/`wrap(...)` code containing `~`, please read
<https://ggplot2.tidyverse.org/news/#tidy-evaluation>.


## **`ggplot2`** themes

Usually plots with white background look more readable when printed. Every
single component of a `ggplot` graph can be customized using the generic
`theme()` function, as we will see below. However, there are pre-loaded themes 
available that change the overall appearance of the graph without much effort. 

For example, we can change our previous graph to have a simpler white background 
using the `theme_bw()` function:

```{r first-facet-white-bg, purl=FALSE}
cnts_sml_long %>%
  # Filter out three genes
  filter(gene %in% c("Evc", "Mpc2", "Nemf")) %>%
  # Create a separate barplot for each gene
  ggplot(aes(x = sample, y = cnt, fill = genotype)) +
    geom_bar(stat = "identity") +
    facet_wrap(facets = vars(gene)) +
    theme_bw()
```

In addition to `theme_bw()`, which changes the plot background to white,
**`ggplot2`** comes with several other themes which can be useful to quickly
change the look of your visualization. The complete list of themes is available
at <https://ggplot2.tidyverse.org/reference/ggtheme.html>. `theme_minimal()` and
`theme_light()` are popular, and `theme_void()` can be useful as a starting
point to create a new hand-crafted theme.

The [ggthemes](https://jrnold.github.io/ggthemes/reference/index.html) package
provides a wide variety of options.

> ## Challenge 5.4
>
> Use what you just learned to create a plot that show how the mean count for
> each genotype differ between the three genes "Evc", "Mpc" and "Nemf".
>
>> ## Solution
>> 
>> ```{r average-gene-counts, message=FALSE, purl=FALSE}
cnts_sml_long %>%
  filter(gene %in% c("Evc", "Mpc2", "Nemf")) %>%
  group_by(gene, genotype) %>%
  summarize(mean=mean(cnt)) %>%
  ggplot(aes(x = genotype, y = mean)) +
    geom_bar(stat = "identity") +
    facet_wrap(vars(gene))
```
> {: .solution}
{: .challenge}


## Customization

Take a look at the [**`ggplot2`** cheat sheet](https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf), and
think of ways you could improve the plot.

Now, let's start with changing the names of axes and add a title to the figure:

```{r gene-counts-with-right-labels, purl = FALSE}
cnts_sml_long %>%
  # Filter out three genes
  filter(gene %in% c("Evc", "Mpc2", "Nemf")) %>%
  # Create a separate barplot for each gene
  ggplot(aes(x = sample, y = cnt, fill = genotype)) +
    geom_bar(stat = "identity") +
    facet_wrap(facets = vars(gene)) +
    labs(title = "Number of reads for selected genes",
         x = "Genotype",
         y = "Number of reads") +
    theme_bw()
```

The axes have more informative names, but their readability can be improved by
increasing the font size. This can be done with the generic `theme()` function:

```{r gene-counts-with-right-labels-xfont-size, purl=FALSE}
cnts_sml_long %>%
  # Filter out three genes
  filter(gene %in% c("Evc", "Mpc2", "Nemf")) %>%
  # Create a separate barplot for each gene
  ggplot(aes(x = sample, y = cnt, fill = genotype)) +
    geom_bar(stat = "identity") +
    facet_wrap(facets = vars(gene)) +
    labs(title = "Number of reads for selected genes",
         x = "Sample",
         y = "Number of reads") +
    theme_bw() +
    theme(text = element_text(size = 16))  # set the font size of text elements
```

We can also add another layer with the `scale_fill_discrete()` function to
adjust the figure legend:

```{r adjust-figure-legend, purl=FALSE}
cnts_sml_long %>%
  # Filter out three genes
  filter(gene %in% c("Evc", "Mpc2", "Nemf")) %>%
  # Create a separate barplot for each gene
  ggplot(aes(x = sample, y = cnt, fill = genotype)) +
    geom_bar(stat = "identity") +
    facet_wrap(facets = vars(gene)) +
    labs(title = "Number of reads for selected genes",
         x = "Sample",
         y = "Number of reads") +
    scale_fill_discrete(
      name = "Genotype",                        # figure legend title
      labels = c("Wild type", "Homozygous")) +  # new figure legend labels
    theme_bw() +
    theme(text = element_text(size = 16))
```

Note that it is also possible to change the fonts of your plots. If you are on
Windows, you may have to install
the [**`extrafont`** package](https://github.com/wch/extrafont), and follow the
instructions included in the README for this package.

After our manipulations, you may notice that the values on the x-axis are still
not properly readable. Let's change the orientation of the labels and adjust 
them vertically and horizontally so they don't overlap. You can use a 90 degree
angle, or experiment to find the appropriate angle for diagonally oriented
labels. We can also modify the facet label text (`strip.text`) to italicize the genus
names:

```{r ngene-counts-with-theme, purl=FALSE}
cnts_sml_long %>%
  # Filter out three genes
  filter(gene %in% c("Evc", "Mpc2", "Nemf")) %>%
  # Create a separate barplot for each gene
  ggplot(aes(x = sample, y = cnt, fill = genotype)) +
    geom_bar(stat = "identity") +
    facet_wrap(facets = vars(gene)) +
    labs(title = "Number of reads for selected genes",
         x = "Genotype",
         y = "Number of reads") +
    theme_bw() +
    theme(axis.text.x = element_text(colour = "grey20", size = 12, angle = 90, hjust = 0.5, vjust = 0.5),
                        axis.text.y = element_text(colour = "grey20", size = 12),
                        strip.text = element_text(face = "italic"),
                        text = element_text(size = 16))
```

If you like the changes you created better than the default theme, you can save
them as an object to be able to easily apply them to other plots you may create:


```{r gene-counts-with-right-labels-xfont-orientation, purl = FALSE}
grey_theme <- theme(axis.text.x = element_text(colour="grey20", size = 12, 
                                               angle = 90, hjust = 0.5, 
                                               vjust = 0.5),
                    axis.text.y = element_text(colour = "grey20", size = 12),
                    text=element_text(size = 16))

cnts_sml_long %>%
  # Filter out three genes
  filter(gene %in% c("Evc", "Mpc2", "Nemf")) %>%
  # Create a separate barplot for each gene
  ggplot(aes(x = sample, y = cnt, fill = genotype)) +
    geom_bar(stat = "identity") +
    facet_wrap(facets = vars(gene)) +
    labs(title = "Number of reads for selected genes",
         x = "Genotype",
         y = "Number of reads") +
    grey_theme
```

> ## Challenge 5.5
>
> With all of this information in hand, please take another five minutes to either
> improve one of the plots generated in this exercise or create a beautiful graph
> of your own. Use the RStudio [**`ggplot2`** cheat sheet](https://www.rstudio.com/wp-content/uploads/2016/11/ggplot2-cheatsheet-2.1.pdf) 
> for inspiration.
>
> Here are some ideas:
>
> * See if you can change the thickness of the lines.
> * Can you find a way to change the name of the legend? What about its labels?
> * Try using a different color palette (see
>   [http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/](http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/)).
{: .challenge

## Arranging plots

Faceting is a great tool for splitting one plot into multiple plots, but 
sometimes you may want to produce a single figure that contains multiple plots
using different variables or even different data frames. We won't go into 
it here, but the * **`patchwork`** package can be used to combine separate 
gplots into a single figure while keeping everything aligned properly. Like most
R packages, `patchwork` can be installed from CRAN, the R package repository.


## Exporting plots

After creating your plot, you can save it to a file in your favorite format. The
Export tab in the **Plot** pane in RStudio will save your plots at low 
resolution, which will not be accepted by many journals and will not scale well 
for posters. The [**`ggplot2`** extensions website](https://exts.ggplot2.tidyverse.org/)
provides a list of packages that extend the capabilities of **`ggplot2`**,
including additional themes.

Instead, use the `ggsave()` function, which allows you easily change the 
dimension and resolution of your plot by adjusting the appropriate arguments 
(`width`, `height` and `dpi`):

```{r ggsave-example, eval = FALSE, purl = FALSE}
cnts_plot <- cnts_sml_long %>%
  # Filter out three genes
  filter(gene %in% c("Evc", "Mpc2", "Nemf")) %>%
  # Create a separate barplot for each gene
  ggplot(aes(x = sample, y = cnt, fill = genotype)) +
    geom_bar(stat = "identity") +
    facet_wrap(facets = vars(gene)) +
    labs(title = "Number of reads for selected genes",
         x = "Sample",
         y = "Number of reads") +
    scale_fill_discrete(
      name = "Genotype",
      labels = c("Wild type", "Homozygous")) + 
    theme_bw() +
    theme(text = element_text(size = 16))

# Save the file
ggsave("gene_counts_plot.png", cnts_plot, width = 15, height = 10)
```
